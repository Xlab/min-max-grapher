/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package minmax.gui;

import java.awt.*;
import javax.media.opengl.GLJPanel;

/**
 *
 * @author Kouprianov Maxim <me@kc.vc> @ SE HSE
 */
public class Plotter extends GLJPanel {

    private Point tmpViewboxCenter;
    private Point viewboxCorner;
    private Point gridCenter;
    private Point viewboxCenter;
    private int viewboxW;
    private int viewboxH;
    private Point startDrag = new Point(0, 0);
    private Point currentDrag = new Point(0, 0);
    private int cellSize;
    
    public Plotter() {
        initComponents();
        gridCenter = new Point(gridBounds / 2, gridBounds / 2);
        viewboxCenter = gridCenter.getLocation();
        cellSize = 20;
        viewboxCorner = new Point(0, 0);
    }
    private int gridBounds = 100;

    public int getGridBounds() {
        return gridBounds;
    }

    private int getMinX() {
        return 0 - gridBounds;
    }

    private int getMinY() {
        return 0 - gridBounds;
    }

    private int getMaxX() {
        return 0 + gridBounds;
    }

    private int getMaxY() {
        return 0 + gridBounds;
    }
    private double zoom = 1.0;

    public double getZoom() {
        return zoom;
    }

    public void setZoom(double zoom) {
        if (zoom >= 0.4 && zoom <= 2) {
            this.zoom = zoom;
            cellSize = (int) (20.0 * zoom);
        }
    }

    public void setGridBounds(int gridBounds) {
        this.gridBounds = gridBounds;
        gridCenter = new Point(gridBounds / 2, gridBounds / 2);
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                iZoom(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                Plotter.this.mousePressed(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                Plotter.this.mouseDragged(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void iZoom(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_iZoom
        setZoom(getZoom() + evt.getWheelRotation() * 0.1);
        //repaint();
    }//GEN-LAST:event_iZoom

    private void mousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mousePressed
        startDrag = evt.getPoint();
        tmpViewboxCenter = viewboxCenter.getLocation();
    }//GEN-LAST:event_mousePressed

    private void mouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mouseDragged
        currentDrag = evt.getPoint();
        viewboxCorner = currentDrag.getLocation();
        viewboxCenter = new Point(tmpViewboxCenter.x - (currentDrag.x - startDrag.x) / cellSize, tmpViewboxCenter.y - (currentDrag.y - startDrag.y) / cellSize);
        repaint();
    }//GEN-LAST:event_mouseDragged

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        Graphics2D g2 = (Graphics2D)g;

                g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED);
        g2.setStroke(new BasicStroke(1.0f,
                        BasicStroke.CAP_BUTT,
                        BasicStroke.JOIN_MITER,
                        10.0f, new float[]{2.0f}, 0.0f));
        
        final int w = getSize().width;
        final int h = getSize().height;
        final int kX = (currentDrag.x - startDrag.x) % cellSize;
        final int kY = (currentDrag.y - startDrag.y) % cellSize;
        
        viewboxW = w / (2 * cellSize);
        viewboxH = h / (2 * cellSize);
        
        final int testR = 2;

        g.setColor(Color.decode("#f4f4f4"));
        g.fillRect(0, 0, w, h);


        //Layer1
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
        g2.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED);
        int column = 0;
        for (int i = viewboxCenter.x - viewboxW; i <= viewboxCenter.x + viewboxW + 2; ++i) {
            if (i != gridCenter.x) {
                g.setColor(Color.decode("#dddddd"));
                g.drawLine(column * cellSize + kX, 0, column * cellSize + kX, h);
            }

            int row = 0;
            for (int j = viewboxCenter.y - viewboxH; j <= viewboxCenter.y + viewboxH +2; ++j) {
                if (j != gridCenter.y) {
                    g.setColor(Color.decode("#dddddd"));
                    g.drawLine(0, row * cellSize + kY, w, row * cellSize + kY);

                }
                ++row;
            }
            ++column;
        }
        
        //Layer 2
        g2.setStroke(new BasicStroke(1.0f));
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
        g2.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED);
        column = 0;
        for (int i = viewboxCenter.x - viewboxW; i <= viewboxCenter.x + viewboxW + 1; ++i) {
            if (i == gridCenter.x) {
                g.setColor(Color.black);
                g.drawLine(column * cellSize + kX, 0, column * cellSize + kX, h);
            }
            int row = 0;
            for (int j = viewboxCenter.y - viewboxH; j <= viewboxCenter.y + viewboxH + 1; ++j) {
                if (j == gridCenter.y) {
                    g.setColor(Color.black);
                    
                    g.drawLine(0, row * cellSize + kY, w, row * cellSize + kY);
                }
                ++row;
            }
            ++column;
        }
        
        //Layer 3
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        //g2.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
        //g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        //g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
        g2.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED);
        column = 0;
        for (int i = viewboxCenter.x - viewboxW; i <= viewboxCenter.x + viewboxW + 1; ++i) {
            int row = 0;
            for (int j = viewboxCenter.y - viewboxH; j <= viewboxCenter.y + viewboxH + 1; ++j) {

                if (i == gridCenter.x + 5 && j == gridCenter.y + 5) {
                    g.setColor(Color.red);
                    g.fillOval(column * cellSize + kX - testR, row * cellSize + kY - testR, testR*2 +1, testR*2+1);
                }

                if (i == gridCenter.x + 6 && j == gridCenter.x + 5) {
                    g.setColor(Color.blue);
                    g.fillOval(column * cellSize + kX - testR, row * cellSize + kY -testR, testR*2 +1, testR*2+1);
                }
                ++row;
            }
            ++column;
        }
    }
}
